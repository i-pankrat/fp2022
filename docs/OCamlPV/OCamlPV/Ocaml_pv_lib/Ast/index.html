<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ast (OCamlPV.Ocaml_pv_lib.Ast)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">OCamlPV</a> &#x00BB; <a href="../index.html">Ocaml_pv_lib</a> &#x00BB; Ast</nav><header class="odoc-preamble"><h1>Module <code><span>Ocaml_pv_lib.Ast</span></code></h1><p>Copyright 2022-2023, Ilya Pankratov</p></header><div class="odoc-content"><p>SPDX-License-Identifier: LGPL-3.0-or-later</p><div class="odoc-spec"><div class="spec type" id="type-id" class="anchored"><a href="#type-id" class="anchor"></a><code><span><span class="keyword">type</span> id</span><span> = string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_id" class="anchored"><a href="#val-equal_id" class="anchor"></a><code><span><span class="keyword">val</span> equal_id : <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_id" class="anchored"><a href="#val-pp_id" class="anchor"></a><code><span><span class="keyword">val</span> pp_id : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_id" class="anchored"><a href="#val-show_id" class="anchor"></a><code><span><span class="keyword">val</span> show_id : <span><a href="#type-id">id</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-const" class="anchored"><a href="#type-const" class="anchor"></a><code><span><span class="keyword">type</span> const</span><span> = </span></code><table><tr id="type-const.CInt" class="anchored"><td class="def variant constructor"><a href="#type-const.CInt" class="anchor"></a><code><span>| </span><span><span class="constructor">CInt</span> <span class="keyword">of</span> int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents integer numbers: ..., -1, 0, 1, ...</p><span class="comment-delim">*)</span></td></tr><tr id="type-const.CBool" class="anchored"><td class="def variant constructor"><a href="#type-const.CBool" class="anchor"></a><code><span>| </span><span><span class="constructor">CBool</span> <span class="keyword">of</span> bool</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents boolean values: false and true</p><span class="comment-delim">*)</span></td></tr><tr id="type-const.CNil" class="anchored"><td class="def variant constructor"><a href="#type-const.CNil" class="anchor"></a><code><span>| </span><span><span class="constructor">CNil</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents empty list: </p><span class="comment-delim">*)</span></td></tr><tr id="type-const.CString" class="anchored"><td class="def variant constructor"><a href="#type-const.CString" class="anchor"></a><code><span>| </span><span><span class="constructor">CString</span> <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents string values: &quot;Hello, world!&quot;</p><span class="comment-delim">*)</span></td></tr><tr id="type-const.CUnit" class="anchored"><td class="def variant constructor"><a href="#type-const.CUnit" class="anchor"></a><code><span>| </span><span><span class="constructor">CUnit</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Repsenets ()</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_const" class="anchored"><a href="#val-equal_const" class="anchor"></a><code><span><span class="keyword">val</span> equal_const : <span><a href="#type-const">const</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-const">const</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_const" class="anchored"><a href="#val-pp_const" class="anchor"></a><code><span><span class="keyword">val</span> pp_const : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-const">const</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_const" class="anchored"><a href="#val-show_const" class="anchor"></a><code><span><span class="keyword">val</span> show_const : <span><a href="#type-const">const</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-bin_op" class="anchored"><a href="#type-bin_op" class="anchor"></a><code><span><span class="keyword">type</span> bin_op</span><span> = </span></code><table><tr id="type-bin_op.Plus" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Plus" class="anchor"></a><code><span>| </span><span><span class="constructor">Plus</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Addition: +</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Minus" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Minus" class="anchor"></a><code><span>| </span><span><span class="constructor">Minus</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Subtraction: -</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Mult" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Mult" class="anchor"></a><code><span>| </span><span><span class="constructor">Mult</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Multiplication: *</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Divide" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Divide" class="anchor"></a><code><span>| </span><span><span class="constructor">Divide</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Division: /</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Mod" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Module: %</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.And" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.And" class="anchor"></a><code><span>| </span><span><span class="constructor">And</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Boolean operator: &amp;&amp;</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Or" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Or" class="anchor"></a><code><span>| </span><span><span class="constructor">Or</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Boolean operator: ||</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Eq" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Comparison operator: =</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Neq" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Neq" class="anchor"></a><code><span>| </span><span><span class="constructor">Neq</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Comparison operator: &lt;&gt;</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Gt" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Comparison operator: &gt;</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Lt" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Comparison operator: &lt;</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Gtq" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Gtq" class="anchor"></a><code><span>| </span><span><span class="constructor">Gtq</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Comparison operator: &gt;=</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.Ltq" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.Ltq" class="anchor"></a><code><span>| </span><span><span class="constructor">Ltq</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Comparison operator: &lt;=</p><span class="comment-delim">*)</span></td></tr><tr id="type-bin_op.ConsConcat" class="anchored"><td class="def variant constructor"><a href="#type-bin_op.ConsConcat" class="anchor"></a><code><span>| </span><span><span class="constructor">ConsConcat</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Add element to the head of the list: 1 :: <code>2; 3</code> = <code>1; 2; 3</code></p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_bin_op" class="anchored"><a href="#val-equal_bin_op" class="anchor"></a><code><span><span class="keyword">val</span> equal_bin_op : <span><a href="#type-bin_op">bin_op</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-bin_op">bin_op</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_bin_op" class="anchored"><a href="#val-pp_bin_op" class="anchor"></a><code><span><span class="keyword">val</span> pp_bin_op : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-bin_op">bin_op</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_bin_op" class="anchored"><a href="#val-show_bin_op" class="anchor"></a><code><span><span class="keyword">val</span> show_bin_op : <span><a href="#type-bin_op">bin_op</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-pattern" class="anchored"><a href="#type-pattern" class="anchor"></a><code><span><span class="keyword">type</span> pattern</span><span> = </span></code><table><tr id="type-pattern.PConst" class="anchored"><td class="def variant constructor"><a href="#type-pattern.PConst" class="anchor"></a><code><span>| </span><span><span class="constructor">PConst</span> <span class="keyword">of</span> <a href="#type-const">const</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents constant patterns</p><span class="comment-delim">*)</span></td></tr><tr id="type-pattern.PVar" class="anchored"><td class="def variant constructor"><a href="#type-pattern.PVar" class="anchor"></a><code><span>| </span><span><span class="constructor">PVar</span> <span class="keyword">of</span> <a href="#type-id">id</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents varuable patterns</p><span class="comment-delim">*)</span></td></tr><tr id="type-pattern.PTuple" class="anchored"><td class="def variant constructor"><a href="#type-pattern.PTuple" class="anchor"></a><code><span>| </span><span><span class="constructor">PTuple</span> <span class="keyword">of</span> <span><a href="#type-pattern">pattern</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Repsenets tuple pattern: (a, b)</p><span class="comment-delim">*)</span></td></tr><tr id="type-pattern.PCons" class="anchored"><td class="def variant constructor"><a href="#type-pattern.PCons" class="anchor"></a><code><span>| </span><span><span class="constructor">PCons</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a> * <a href="#type-pattern">pattern</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents the head :: tail pattern</p><span class="comment-delim">*)</span></td></tr><tr id="type-pattern.PWild" class="anchored"><td class="def variant constructor"><a href="#type-pattern.PWild" class="anchor"></a><code><span>| </span><span><span class="constructor">PWild</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Representa pattern that shows that each case is an appropriate: _</p><span class="comment-delim">*)</span></td></tr><tr id="type-pattern.PPolyVariant" class="anchored"><td class="def variant constructor"><a href="#type-pattern.PPolyVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">PPolyVariant</span> <span class="keyword">of</span> <a href="#type-id">id</a> * <span><a href="#type-pattern">pattern</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Polymorphic variants. Number of the elements in the list represents the number of arguments which contructor takes</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-pvtype" class="anchored"><a href="#type-pvtype" class="anchor"></a><code><span><span class="keyword">and</span> pvtype</span><span> = </span></code><table><tr id="type-pvtype.TTuple" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TTuple" class="anchor"></a><code><span>| </span><span><span class="constructor">TTuple</span> <span class="keyword">of</span> <span><a href="#type-pvtype">pvtype</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents tuple type: int * int</p><span class="comment-delim">*)</span></td></tr><tr id="type-pvtype.TList" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TList" class="anchor"></a><code><span>| </span><span><span class="constructor">TList</span> <span class="keyword">of</span> <a href="#type-pvtype">pvtype</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents list type: int list</p><span class="comment-delim">*)</span></td></tr><tr id="type-pvtype.TType" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TType" class="anchor"></a><code><span>| </span><span><span class="constructor">TType</span> <span class="keyword">of</span> <a href="#type-id">id</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents declared type: my_type</p><span class="comment-delim">*)</span></td></tr><tr id="type-pvtype.TAny" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TAny" class="anchor"></a><code><span>| </span><span><span class="constructor">TAny</span> <span class="keyword">of</span> <a href="#type-id">id</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents parameter at type declaration</p><span class="comment-delim">*)</span></td></tr><tr id="type-pvtype.TInt" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TInt" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents int type</p><span class="comment-delim">*)</span></td></tr><tr id="type-pvtype.TString" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TString" class="anchor"></a><code><span>| </span><span><span class="constructor">TString</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents string type</p><span class="comment-delim">*)</span></td></tr><tr id="type-pvtype.TBool" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TBool" class="anchor"></a><code><span>| </span><span><span class="constructor">TBool</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents boolean type</p><span class="comment-delim">*)</span></td></tr><tr id="type-pvtype.TNoType" class="anchored"><td class="def variant constructor"><a href="#type-pvtype.TNoType" class="anchor"></a><code><span>| </span><span><span class="constructor">TNoType</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents that declared constructor has no arguments</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Show the type of constructors</p></div></div><div class="odoc-spec"><div class="spec type" id="type-parameters" class="anchored"><a href="#type-parameters" class="anchor"></a><code><span><span class="keyword">and</span> parameters</span><span> = <span><a href="#type-id">id</a> list</span></span></code></div><div class="spec-doc"><p>Represents parameters at type declaration: type 'a 'b my_typ = ...</p></div></div><div class="odoc-spec"><div class="spec type" id="type-expr" class="anchored"><a href="#type-expr" class="anchor"></a><code><span><span class="keyword">and</span> expr</span><span> = </span></code><table><tr id="type-expr.EConst" class="anchored"><td class="def variant constructor"><a href="#type-expr.EConst" class="anchor"></a><code><span>| </span><span><span class="constructor">EConst</span> <span class="keyword">of</span> <a href="#type-const">const</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents constasnts</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.EIfThenElse" class="anchored"><td class="def variant constructor"><a href="#type-expr.EIfThenElse" class="anchor"></a><code><span>| </span><span><span class="constructor">EIfThenElse</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents condition statement: if expr then expr else expr</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.ELet" class="anchored"><td class="def variant constructor"><a href="#type-expr.ELet" class="anchor"></a><code><span>| </span><span><span class="constructor">ELet</span> <span class="keyword">of</span> <a href="#type-id">id</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents let declaration: let id = expr</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.ELetIn" class="anchored"><td class="def variant constructor"><a href="#type-expr.ELetIn" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetIn</span> <span class="keyword">of</span> <a href="#type-id">id</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents let in declaraion: let id = expr in expr</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.ELetRec" class="anchored"><td class="def variant constructor"><a href="#type-expr.ELetRec" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetRec</span> <span class="keyword">of</span> <a href="#type-id">id</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents let rec declaration: let rec id = expr</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.ELetRecIn" class="anchored"><td class="def variant constructor"><a href="#type-expr.ELetRecIn" class="anchor"></a><code><span>| </span><span><span class="constructor">ELetRecIn</span> <span class="keyword">of</span> <a href="#type-id">id</a> * <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents let rec in declaration: let rec id = expr in expr</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.EMatch" class="anchored"><td class="def variant constructor"><a href="#type-expr.EMatch" class="anchor"></a><code><span>| </span><span><span class="constructor">EMatch</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <span><span>(<a href="#type-pattern">pattern</a> * <a href="#type-expr">expr</a>)</span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents pattern matching: match expr with (pattern * expr) list</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.EBinOp" class="anchored"><td class="def variant constructor"><a href="#type-expr.EBinOp" class="anchor"></a><code><span>| </span><span><span class="constructor">EBinOp</span> <span class="keyword">of</span> <a href="#type-bin_op">bin_op</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents binaty operations: +, -, *, /, ...</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.EVar" class="anchored"><td class="def variant constructor"><a href="#type-expr.EVar" class="anchor"></a><code><span>| </span><span><span class="constructor">EVar</span> <span class="keyword">of</span> <a href="#type-id">id</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents variables</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.EFun" class="anchored"><td class="def variant constructor"><a href="#type-expr.EFun" class="anchor"></a><code><span>| </span><span><span class="constructor">EFun</span> <span class="keyword">of</span> <a href="#type-pattern">pattern</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents anonymous function: fun pattern -&gt; expr</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.EApply" class="anchored"><td class="def variant constructor"><a href="#type-expr.EApply" class="anchor"></a><code><span>| </span><span><span class="constructor">EApply</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents function and binary operation application to the arguments</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.EList" class="anchored"><td class="def variant constructor"><a href="#type-expr.EList" class="anchor"></a><code><span>| </span><span><span class="constructor">EList</span> <span class="keyword">of</span> <a href="#type-expr">expr</a> * <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represents list: expr :: expr</p><span class="comment-delim">*)</span></td></tr><tr id="type-expr.ETuple" class="anchored"><td class="def variant constructor"><a href="#type-expr.ETuple" class="anchor"></a><code><span>| </span><span><span class="constructor">ETuple</span> <span class="keyword">of</span> <span><a href="#type-expr">expr</a> list</span></span></code></td></tr><tr id="type-expr.EPolyVariant" class="anchored"><td class="def variant constructor"><a href="#type-expr.EPolyVariant" class="anchor"></a><code><span>| </span><span><span class="constructor">EPolyVariant</span> <span class="keyword">of</span> <a href="#type-id">id</a> * <span><a href="#type-expr">expr</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Polymorphic variants, where id represents constructor and expr -- arguments</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_pattern" class="anchored"><a href="#val-equal_pattern" class="anchor"></a><code><span><span class="keyword">val</span> equal_pattern : <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_pvtype" class="anchored"><a href="#val-equal_pvtype" class="anchor"></a><code><span><span class="keyword">val</span> equal_pvtype : <span><a href="#type-pvtype">pvtype</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pvtype">pvtype</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_parameters" class="anchored"><a href="#val-equal_parameters" class="anchor"></a><code><span><span class="keyword">val</span> equal_parameters : <span><a href="#type-parameters">parameters</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-parameters">parameters</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_expr" class="anchored"><a href="#val-equal_expr" class="anchor"></a><code><span><span class="keyword">val</span> equal_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.bool</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_pattern" class="anchored"><a href="#val-pp_pattern" class="anchor"></a><code><span><span class="keyword">val</span> pp_pattern : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_pattern" class="anchored"><a href="#val-show_pattern" class="anchor"></a><code><span><span class="keyword">val</span> show_pattern : <span><a href="#type-pattern">pattern</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_pvtype" class="anchored"><a href="#val-pp_pvtype" class="anchor"></a><code><span><span class="keyword">val</span> pp_pvtype : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-pvtype">pvtype</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_pvtype" class="anchored"><a href="#val-show_pvtype" class="anchor"></a><code><span><span class="keyword">val</span> show_pvtype : <span><a href="#type-pvtype">pvtype</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_parameters" class="anchored"><a href="#val-pp_parameters" class="anchor"></a><code><span><span class="keyword">val</span> pp_parameters : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-parameters">parameters</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_parameters" class="anchored"><a href="#val-show_parameters" class="anchor"></a><code><span><span class="keyword">val</span> show_parameters : <span><a href="#type-parameters">parameters</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_expr" class="anchored"><a href="#val-pp_expr" class="anchor"></a><code><span><span class="keyword">val</span> pp_expr : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_expr" class="anchored"><a href="#val-show_expr" class="anchor"></a><code><span><span class="keyword">val</span> show_expr : <span><a href="#type-expr">expr</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-declaration" class="anchored"><a href="#type-declaration" class="anchor"></a><code><span><span class="keyword">type</span> declaration</span><span> = </span></code><table><tr id="type-declaration.DExpr" class="anchored"><td class="def variant constructor"><a href="#type-declaration.DExpr" class="anchor"></a><code><span>| </span><span><span class="constructor">DExpr</span> <span class="keyword">of</span> <a href="#type-expr">expr</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Expressions</p><span class="comment-delim">*)</span></td></tr><tr id="type-declaration.DType" class="anchored"><td class="def variant constructor"><a href="#type-declaration.DType" class="anchor"></a><code><span>| </span><span><span class="constructor">DType</span> <span class="keyword">of</span> <a href="#type-id">id</a> * <a href="#type-parameters">parameters</a> * <span><span>(<a href="#type-id">id</a> * <a href="#type-pvtype">pvtype</a>)</span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Represent typ declaration: type parameters id = (id * pvtype) list. It is possible to declare only polymorphic variants.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_declaration" class="anchored"><a href="#val-pp_declaration" class="anchor"></a><code><span><span class="keyword">val</span> pp_declaration : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-declaration">declaration</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_declaration" class="anchored"><a href="#val-show_declaration" class="anchor"></a><code><span><span class="keyword">val</span> show_declaration : <span><a href="#type-declaration">declaration</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-statements" class="anchored"><a href="#type-statements" class="anchor"></a><code><span><span class="keyword">type</span> statements</span><span> = <span><a href="#type-declaration">declaration</a> list</span></span></code></div><div class="spec-doc"><p>Represents the sequence of expr</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_statements" class="anchored"><a href="#val-pp_statements" class="anchor"></a><code><span><span class="keyword">val</span> pp_statements : 
  <span><span class="xref-unresolved">Ppx_deriving_runtime</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-statements">statements</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Ppx_deriving_runtime</span>.unit</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-show_statements" class="anchored"><a href="#val-show_statements" class="anchor"></a><code><span><span class="keyword">val</span> show_statements : <span><a href="#type-statements">statements</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Ppx_deriving_runtime</span>.string</span></code></div></div></div></body></html>